# Домашнее задание к занятию «2.2 Кэширование данных - использование из Go»

Все задачи этого занятия нужно делать в **одном репозитории**.

В качестве результата пришлите ссылки на ваши GitHub-проекты через личный кабинет студента на сайте [netology.ru](https://netology.ru).

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

**ВАЖНО**: НИ В КОЕМ СЛУЧАЕ НЕ ПОДСТАВЛЯЙТЕ ДАННЫЕ СВОИХ РЕАЛЬНЫХ КАРТ В КОД! Это очень частая "оплошность": разработчики случайно коммитят и заливают на GitHub "чувствительные" (sensitive) данные (ключи, логины, пароли, адреса и т.д.). Используйте генераторы вроде: https://www.freeformatter.com/credit-card-number-generator-validator.html

Если вы всё же "случайно" залили чувствительные данные на GitHub, то используйте [инструкцию по удалению данных](https://help.github.com/en/github/authenticating-to-github/removing-sensitive-data-from-a-repository). Кроме того, как бы это печально ни было, рекомендуем вам заблокировать карту и заказать в банке новую.

## Как сдавать задачи

1. Создайте на вашем компьютере Go-модуль (см. доп.видео к первой лекции).
1. Добавьте в него в качестве зависимостей pgx, mongo, redigo.
1. Инициализируйте в нём пустой Git-репозиторий.
1. Добавьте в него готовый файл [.gitignore](../.gitignore).
1. Добавьте в этот же каталог остальные необходимые файлы (убедитесь, что они аккуратно разложены по пакетам).
1. Сделайте необходимые коммиты.
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым.
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub).
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru).
1. Задачи, отмеченные как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными).

## Кэш предсказаний для пользователей

### Легенда

<details>
<summary>Легенда</summary>

В одном из прошлых ДЗ вы проектировали базу для хранения частых платежей и предсказаний.  

Пример того, как это выглядело:

![](../02_mongodb/pic/payments01.png)

![](../02_mongodb/pic/payments02.png)

А также вы реализовали механизмы разграничения доступа.

Пришло время обеспечить кэширование этих самых предсказаний для пользователей (в зависимости от пользователя, конечно же).

</details>

### Задача

1. Нужно взять проект с ДЗ к лекции 1.3 (отрабатываем ситуацию последовательного развития сервиса)
1. Вставить time.Sleep в handler'ы для получения предсказаний из MongoDB в 3 секунды (эмулируем ситуацию медленного ответа из БД предсказаний)
1. Реализовать то, что обсуждалось в лекции: переписать функции для Cache Middleware так, чтобы в ключе сохранялся id пользователя (т.е. для первого будет: `users:1:suggestions`, а для второго: `users:2:suggestions`, либо любая иная схема именования, которая вам нравится).

<details>
<summary>Подсказка</summary>

Для этого не нужно переписывать сам Middleware. Нужно переписать только функции, передаваемые в `Cache` (`fromCache` и `toCache`)
</details>

Примечание: стоит отметить, что ситуация, описываемая в данном проекте, предназначена для отработки работы с Redis. Вполне возможно, что если в MongoDB будут храниться только предсказания, то работать она будет достаточно быстро, и кэш вам не потребуется (т.е. нужно будет измерять скорость с кэшем и без - есть ли выигрыш или мы зря ходим в кэш). Поэтому мы вставляем задержку в 3 секунды (чтобы эмулировать ситуацию).

Как проверить:
1. Аутентифицированным пользователем с id = 1 делаете запрос на `/suggestions` - данные берутся из MongoDB и кладутся в кэш (пользователю, естественно, тоже возвращаются)
1. Аутентифицированным пользователем с id = 1 делаете запрос на `/suggestions` - данные берутся из кэша (поход в MongoDB не осуществляется)
1. Аутентифицированным пользователем с id = 2 делаете запрос на `/suggestions` - данные берутся из MongoDB и кладутся в кэш (пользователю, естественно, тоже возвращаются)
1. Аутентифицированным пользователем с id = 2 делаете запрос на `/suggestions` - данные берутся из кэша (поход в MongoDB не осуществляется)
1. Аутентифицированным пользователем с id = 1 делаете запрос на `/suggestions` - данные берутся из кэша (поход в MongoDB не осуществляется)
1. Аутентифицированным пользователем с id = 2 делаете запрос на `/suggestions` - данные берутся из кэша (поход в MongoDB не осуществляется)

Не забудьте приложить запросы (либо через Go `http.Client`, либо через автотесты, либо запросы в формате `requests.http`), демонстрирующие вызовы вашего API (**без них ДЗ будет отправлено на доработку**).

Реализовывать регистрацию и другие функции не нужно. Требуются только аутентификация, просмотр для пользователя и добавление/обновление для внешнего сервиса. 

Итого:
* в PostgreSQL хранятся пользователи (вместе с паролями)
* в MongoDB "предсказания" (документ вида: id пользователя + предсказания для него)
* В Redis хранятся кэшированные предсказания из MongoDB по пользователям

В качестве результата пришлите ссылку на ваш GitHub-проект, в котором реализованы описанные выше требования.

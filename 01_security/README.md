# Домашнее задание к занятию «1.1. Идентификация, аутентификация и авторизация»

В качестве результата пришлите ссылки на ваши GitHub-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

Все задачи этого занятия нужно делать в **одном репозитории**.

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

**ВАЖНО**: НИ В КОЕМ СЛУЧАЕ НЕ ПОДСТАВЛЯЙТЕ ДАННЫЕ СВОИХ РЕАЛЬНЫХ КАРТ В КОД! Это очень частая "оплошность", когда разработчики случайно коммитят и заливают на GitHub "чувствительные" (sensitive) данные (ключи, логины, пароли, адреса и т.д.). Используйте генераторы вроде: https://www.freeformatter.com/credit-card-number-generator-validator.html

Если вы всё же "случайно" залили чувствительные данные на GitHub, то используйте [инструкцию по удалению данных](https://help.github.com/en/github/authenticating-to-github/removing-sensitive-data-from-a-repository). Кроме того, как бы это печально не было, рекомендуем вам заблокировать карту и заказать в банке новую.

## Как сдавать задачи

1. Создайте на вашем компьютере Go-модуль (см. доп.видео к первой лекции)
1. Добавьте в него в качестве зависимостей pgx v4
1. Инициализируйте в нём пустой Git-репозиторий
1. Добавьте в него готовый файл [.gitignore](../.gitignore)
1. Добавьте в этот же каталог остальные необходимые файлы (убедитесь, что они аккуратно разложены по пакетам)
1. Сделайте необходимые коммиты
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub)
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru)
1. Задачи, отмеченные, как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными)

## Задача №1 - Регистрация

### Задача

Мы заканчиваем работу с самописным mux'ом и начинаем использовать промышленный, который называется [Chi](https://github.com/go-chi/chi).

Работа с ним достаточно простая:
```shell script
go get -u github.com/go-chi/chi
```

Далее, по стандартной структуре проекта вместо `mux := remux.NewReMux()` пишем `r := chi.NewMux()` (именно `NewMux`, а не `New`) и т.д. (вы можете посмотреть в [примере](sample)).

Что нужно сделать - нужно сделать регистрацию пользователей.

Пока регистрация пользователей будет достаточно простая:

1\. Вы объявляете URL `/api/users`

2\. Принимаете на него запросы вида:

```json
{
  "login": "vasya",
  "password": "secret"
}
```

3\. Хэшируете пароль с помощью пакета [bcrypt](https://godoc.org/golang.org/x/crypto/bcrypt)

4\. Создаёте пользователя с помощью запроса: `INSERT INTO users(name, password, roles) VALUES($1, $2, $3) ON CONFLICT DO NOTHING RETURNING id`* (вместо `password` конечно же подставляете хэш)

Примечание*: `ON CONFLICT` позволяет указать альтернативные действия при конфликте ключей (а он у вас будет, если вы поставите `UNIQUE` на логин). Таким образом этот запрос вернёт либо `id` созданного пользователя, либо "ничего".

5\. Возвращаете пользователю ответ вида:

5\.1\. В случае успеха (статус 201 `Created`)
```json
{
  "id": 1001
}
```

5\.2\. В случае ошибки (не забудьте выставить 4XX статус ошибки):
```json
{
  "error": "err.username_already_used" 
}
```

Обратите внимание, что могут быть ошибки, связанные с подключением к БД и т.д. В этом случае нужно возвращать 5xx и:
```json
{
  "error": "err.internal_server_error" 
}
```

### О кодах ошибок

**Q**: Зачем мы возвращаем такие коды?

**A**: Всё дело в том, что современный фронтенд (web и mobile) - мультиязычный. Поэтому есть несколько вариантов:
1. Клиент вам вместе с запросом присылает код языка, и вы ищете перевод ошибки (для этого вам нужны переводы на всех языках, которые используются клиентом) и отдаёте уже локализованное сообщение об ошибке: `Внутренняя ошибка сервера` (RU), `Internal Server Error` (EN)
2. Вы не занимаетесь локализацией и отдаёте клиенту код ошибок. Файл локализации либо зашит в сам клиент (плохой вариант, т.к. обновление приложения на девайсах пользователей занимает несколько месяцев), либо клиент скачивает его (вариант получше)
3. Есть всякие гибриды, из серии, сервер отдаёт сообщение сразу на всех поддерживаемых языках

Самый простой для backender'ов - второй.

**Q**: Почему именно второй?

**A**: Если в компании дорожат пользователями, то всегда замечают, что многие вещи, понятные команде разработки, совсем не понятны пользователям. Поэтому человекопонятные сообщения об ошибках часто меняется. В нашем случае это будет означать что:
1. Надо либо делать API для работы с локализацией (где можно с помощью http-запросов поменять/обновить перевод)
1. Либо вносить изменения в код, и перезапускать сервер (целый сервер, на котором сейчас работают тысячи пользователей, мы перезапускаем, чтобы обновить сообщение)

### Результат

В качестве результата пришлите ссылку на ваш GitHub проект, в котором реализована описанная выше логика.

## Задача №2 - Токены

### Задача

Как и в лекции, вам нужно выдавать пользователю токен, в обмен на логин и пароль. Пока это будут "бесконечные" токены, но позже мы научимся делать их более безопасными.

Как всё должно работать:

1\. В проект из первого задания добавляете URL `/tokens`

2\. На этот URL принимаете запросы вида:

```json
{
  "login": "vasya",
  "password": "secret"
}
```

3\. В случае успеха отвечаете ответом вида (не забывайте про возможные ошибки):

```json
{
  "token": "XXXX-XXXX-..."
}
```

Token **пока** вы можете генерировать с помощью пакета [uuid](https://github.com/google/uuid). UUID - это Universally Unique IDentifier, известный также как GUIDs (Globally Unique IDentifier).

**Q**: Почему пока?

**A**: Потому что есть способы гораздо лучше, но для простоты нам **сейчас** будет достаточно и этого. Поскольку пока мы ориентируемся только на строки, мы сможем его заменить на более стойкий к различным атакам.

### Результат

В качестве результата пришлите ссылку на ваш GitHub проект, в котором реализована описанная выше логика.

## Задача №3 - Аутентификация и Авторизация

### Задача

На основе примера с лекции реализуйте на базе [Chi](https://github.com/go-chi/chi) аутентификацию и авторизацию.

Вам нужно сделать следующее:
1. Реализовать "защищённый" `url` `/cards`
1. Пускать на этот `url` только пользователей с ролью `USER` или `ADMIN` (для простоты будем считать, что у нас у пользователя может быть только одна роль, поэтому вам не нужен массив в столбце PostgreSQL)
1. В зависимости от роли:
* если роль `USER`, то показываете список собственных карт пользователя
* если роль `ADMIN`, то показываете список всех карт

Для этого вам нужен middleware. Middleware пишутся так же, как мы и разбирали на лекции, т.е. функция, которая либо возвращает `http.Handler`, либо функция, которая возвращает функцию, которая возвращает `http.Handler`.

Единственное ключевое отличие: в Chi немного по-другому навешивают middleware (см. [пример](sample)):

```go
mux.With(middleware1, middleware2, ..., middlewareN).GET("/url", handler)
```

Мы делали:
```go
mux.GET("/url", handler, middleware1, middleware2, ..., middlewareN)
```

Чтобы не усложнять, мы рекомендуем вам написать middleware, которое выполняет сразу и аутентификацию (вытаскивает выданный токен, на основе него получает профиль), и авторизацию (смотрит в профиле нужные права).

### Результат

В качестве результата пришлите ссылку на ваш GitHub проект, в котором реализована описанная выше логика.

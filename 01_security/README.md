# Домашнее задание к занятию «1.1. Идентификация, аутентификация и авторизация»

Все задачи этого занятия нужно делать в **одном репозитории**.

В качестве результата пришлите ссылки на ваши GitHub-проекты в личном кабинете студента на сайте [netology.ru](https://netology.ru).

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

**ВАЖНО**: НИ В КОЕМ СЛУЧАЕ НЕ ПОДСТАВЛЯЙТЕ ДАННЫЕ СВОИХ РЕАЛЬНЫХ КАРТ В КОД! Это очень частая "оплошность", когда разработчики случайно коммитят и заливают на GitHub "чувствительные" (sensitive) данные (ключи, логины, пароли, адреса и т.д.). Используйте генераторы вроде: https://www.freeformatter.com/credit-card-number-generator-validator.html

Если вы всё же "случайно" залили чувствительные данные на GitHub, то используйте [инструкцию по удалению данных](https://help.github.com/en/github/authenticating-to-github/removing-sensitive-data-from-a-repository). Кроме того, как бы это печально не было, рекомендуем вам заблокировать карту и заказать в банке новую.

## Как сдавать задачи

1. Создайте на вашем компьютере Go-модуль (см. доп.видео к первой лекции)
1. Добавьте в него в качестве зависимостей pgx v4
1. Инициализируйте в нём пустой Git-репозиторий
1. Добавьте в него готовый файл [.gitignore](../.gitignore)
1. Добавьте в этот же каталог остальные необходимые файлы (убедитесь, что они аккуратно разложены по пакетам)
1. Сделайте необходимые коммиты
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub)
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru)
1. Задачи, отмеченные, как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными)

## Задача №1 - Регистрация

### Задача


<details>
<summary>Краткое вступление</summary>

Мы заканчиваем работу с самописным mux'ом и начинаем использовать промышленный, который называется [Chi](https://github.com/go-chi/chi).

Работа с ним достаточно простая:
```shell script
go get -u github.com/go-chi/chi
```

Далее, по стандартной структуре проекта вместо `mux := remux.NewReMux()` пишем `r := chi.NewMux()` (именно `NewMux`, а не `New`) и т.д. (вы можете посмотреть в [примере](sample)).

</details>

Нужно сделать регистрацию пользователей.

Пока регистрация пользователей будет достаточно простая:

1\. Вы объявляете URL `/api/users`

2\. Принимаете на него запросы вида:

```json
{
  "login": "vasya",
  "password": "secret"
}
```

3\. Хэшируете пароль с помощью пакета [bcrypt](https://godoc.org/golang.org/x/crypto/bcrypt)

4\. Создаёте пользователя с помощью запроса: `INSERT INTO users(name, password, roles) VALUES($1, $2, $3) ON CONFLICT DO NOTHING RETURNING id`* (вместо `password` конечно же подставляете хэш)

<details>
<summary>Про ON CONFLICT</summary>

Примечание*: `ON CONFLICT` позволяет указать альтернативные действия при конфликте ключей (а он у вас будет, если вы поставите `UNIQUE` на логин). Таким образом этот запрос вернёт либо `id` созданного пользователя, либо "ничего". Детальнее про [`ON CONFLICT`](https://www.postgresql.org/docs/current/sql-insert.html).
</details>

5\. Возвращаете пользователю ответ вида:

5\.1\. В случае успеха (статус 201 `Created`)
```json
{
  "id": 1001
}
```

5\.2\. В случае ошибки (не забудьте выставить 4XX статус ошибки):
```json
{
  "error": "err.username_already_used" 
}
```

Обратите внимание, что могут быть ошибки, связанные с подключением к БД и т.д. В этом случае нужно возвращать 5xx и:
```json
{
  "error": "err.internal_server_error" 
}
```

[О кодах ошибок](codes.md)

### Результат

В качестве результата пришлите ссылку на ваш GitHub проект, в котором реализована описанная выше логика.

## Задача №2 - Токены

### Задача

Как и в лекции, вам нужно выдавать пользователю токен в обмен на логин и пароль. Пока это будут "бесконечные" токены, но позже мы научимся делать их более безопасными.

Что нужно сделать:

1\. В проект из первого задания добавляете URL `/tokens`

2\. На этот URL принимаете запросы вида:

2\.1\. В упрощённом варианте (обязательный для реализации):

```json
{
  "login": "vasya",
  "password": "secret"
}
```

2\.1\. В усложнённом варианте (необязательный для реализации):

Должна быть поддержка следующих вариантов:

* IP (как на лекции):
<details>
<summary>Подсказка</summary>

Для реализации этого варианта, вам придётся переделать регистрацию, чтобы добавить туда:
- либо **необязательное** поле ip
- либо сделать его обязательным, но для признака **с любого ip** использовать какое-то специально значение, например `*` (диапазоны адресов реализовывать не нужно)

</details>

*  [HTTP Basic](https://tools.ietf.org/html/rfc2617#section-2) (передаётся заголовок `Authorization: Basic base64(username:password)`), для извлечения см. [BasicAuth](https://golang.org/pkg/net/http/#Request.BasicAuth)
* `Content-Type`: `application/json`:

```json
{
  "login": "vasya",
  "password": "secret"
}
```

* `Content-Type`: `x-www-form-urlencoded`:

```
login=vasya&password=secret
```

3\. В случае успеха отвечаете ответом вида (не забывайте про возможные ошибки):

```json
{
  "token": "XXXX-XXXX-..."
}
```

Token **пока** вы можете генерировать с помощью пакета [uuid](https://github.com/google/uuid).

<details>
<summary>Про UUID</summary>

UUID - это Universally Unique IDentifier, известный также как GUIDs (Globally Unique IDentifier).

**Q**: Почему пока?

**A**: Потому что есть способы гораздо лучше, но для простоты нам **сейчас** будет достаточно и этого. Поскольку пока мы ориентируемся только на строки, мы сможем его заменить на более стойкий к различным атакам.

</details>

### Результат

В качестве результата пришлите ссылку на ваш GitHub проект, в котором реализована описанная выше логика.

## Задача №3 - Аутентификация и Авторизация

### Задача

На основе примера с лекции реализуйте на базе [Chi](https://github.com/go-chi/chi) аутентификацию и авторизацию.

Вам нужно сделать следующее:
1. Реализовать "защищённый" `url` `/cards`
1. Пускать на этот `url` только пользователей с ролью `USER` или `ADMIN` (для простоты будем считать, что у нас у пользователя может быть только одна роль, поэтому вам не нужен массив в столбце PostgreSQL)
1. В зависимости от роли:
* если роль `USER`, то показываете список собственных карт пользователя
* если роль `ADMIN`, то показываете список всех карт

Для этого вам нужен middleware.

<details>
<summary>Про Middleware</summary>

Middleware пишутся так же, как мы и разбирали на лекции, т.е. функция, которая либо возвращает `http.Handler`, либо функция, которая возвращает функцию, которая возвращает `http.Handler`.

Единственное ключевое отличие: в Chi немного по-другому навешивают middleware (см. [пример](sample)):

```go
mux.With(middleware1, middleware2, ..., middlewareN).GET("/url", handler)
```

Мы делали:
```go
mux.GET("/url", handler, middleware1, middleware2, ..., middlewareN)
```
</details>

Чтобы не усложнять, мы рекомендуем вам написать middleware, которое выполняет сразу и аутентификацию (вытаскивает выданный токен, на основе него получает профиль), и авторизацию (смотрит в профиле нужные права).

### Результат

В качестве результата пришлите ссылку на ваш GitHub проект, в котором реализована описанная выше логика.

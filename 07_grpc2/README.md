# Домашнее задание к занятию «2.4 gRPC (часть 2)»

Все задачи этого занятия можно делать в **одном репозитории**.

В качестве результата пришлите ссылки на ваши GitHub-проекты через личный кабинет студента на сайте [netology.ru](https://netology.ru).

**Важно**: если у вас что-то не получилось, то оформляйте Issue [по установленным правилам](../report-requirements.md).

## Как сдавать задачи

1. Создайте на вашем компьютере Go-модуль (см. доп.видео к первой лекции).
1. Добавьте в него в качестве зависимостей pgx и всё, что нужно для создания gRPC сервера и клиента.
1. Инициализируйте в нём пустой Git-репозиторий.
1. Добавьте в него готовый файл [.gitignore](../.gitignore).
1. Добавьте в этот же каталог остальные необходимые файлы (убедитесь, что они аккуратно разложены по пакетам).
1. Сделайте необходимые коммиты.
1. Создайте публичный репозиторий на GitHub и свяжите свой локальный репозиторий с удалённым.
1. Сделайте пуш (удостоверьтесь, что ваш код появился на GitHub).
1. Ссылку на ваш проект отправьте в личном кабинете на сайте [netology.ru](https://netology.ru).
1. Задачи, отмеченные как необязательные, можно не сдавать, это не повлияет на получение зачета (в этом ДЗ все задачи являются обязательными).

## Aggregator

### Легенда

<details>
<summary>Легенда</summary>

В наше время достаточно популярны так называемые агрегаторы - т.е. сервисы, которые занимаются сбором предложений с других сервисов, а иногда и продают доп.услуги, в виде сопровождения, страхования и т.д.

Тинькофф предоставляет сервис Путешествия, на котором в числе прочего можно приобрести авиабилеты:

![](pic/aggregator.png)

Что на этом сервисе интересно? Если вы вобьёте данные для поиска, то увидите, что данные подгружаются не единоразово, а "догружаются в процессе":

![](pic/aviasales.png)

Соответственно, мы хотим сделать примерно такую же вещь средствами gRPC: у нас будет клиент и сервер, предоставляющий метод типа Server Stream.

</details>

### Задача

Реализуйте gRPC-сервер и gRPC-клиент в одном проекте (для них должны быть разные бинарники, формируемые из `cmd`), реализующие функциональность поиска с возвратом результатов в виде Server Stream.

Параметры запроса:
* дата
* IATA-код* аэропорта вылета
* IATA-код* аэропорта прилёта

О других данных можете не думать.

Каждое возвращаемое предложение должно содержать следующие данные:
* id
* время вылета
* время в пути
* стоимость

Q: как эмулировать сбор данных с разных сервисов?

A: мы предлагаем вам через Docker Compose создать несколько баз данных (можно с одинаковой структуров), в которых вы и будете искать предложения.

Соответственно, когда вам от клиента приходит запрос, вы запускаете три горутины, каждая из которых ищет в своей базе данных, а результаты скидывает в stream ответа.

**Важно**: посылать данные в stream безопасно можно только из одной горутины (также, как и читать их). Поэтому вам нужно использовать соответствующие механизмы.

<details>
<summary>Детали</summary>

Если вы поковыряетесь во внутренней реализации сгенерированного из .proto Go-файла, то увидите, что вызов `Send` приводит в вызову `SendMsg`:

```go
// It is safe to have a goroutine calling SendMsg and another goroutine
// calling RecvMsg on the same stream at the same time, but it is not safe
// to call SendMsg on the same stream in different goroutines.
SendMsg(m interface{}) error
```
</details>

Итого:
1. Вы пишете `.proto`-файлы, описывающие требуемые операции, типы сообщений - на ваше усмотрение (в соответствии с ДЗ)
1. Вы генерируете на основании `.proto` файлы `*.pb.go`, содержащие интерфейсы для клиента и сервера
1. Вы пишете реализацию сервера - `cmd/avia/server`
1. Вы пишете реализацию клиента - `cmd/avia/client` с демонстрацией запроса поиска и вывода результатов

Сгенерированные в результате работы `protoc`-файлы также должны присутствовать в Git-репозитории, как и `docker-compose.yml` и демо-данные для проверки (`docker-entrypoint-initdb.d` - всё, как проходили).

В качестве результата пришлите ссылку на ваш GitHub-проект, в котором реализованы описанные выше требования.
